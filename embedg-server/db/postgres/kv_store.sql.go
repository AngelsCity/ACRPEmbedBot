// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: kv_store.sql

package postgres

import (
	"context"
	"database/sql"
	"time"
)

const countKVKeys = `-- name: CountKVKeys :one
SELECT COUNT(*) FROM kv_store WHERE guild_id = $1
`

func (q *Queries) CountKVKeys(ctx context.Context, guildID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countKVKeys, guildID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteKVKey = `-- name: DeleteKVKey :one
DELETE FROM kv_store WHERE key = $1 AND guild_id = $2 RETURNING key, guild_id, value, expires_at, created_at, updated_at
`

type DeleteKVKeyParams struct {
	Key     string
	GuildID string
}

func (q *Queries) DeleteKVKey(ctx context.Context, arg DeleteKVKeyParams) (KvStore, error) {
	row := q.db.QueryRowContext(ctx, deleteKVKey, arg.Key, arg.GuildID)
	var i KvStore
	err := row.Scan(
		&i.Key,
		&i.GuildID,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getKVKey = `-- name: GetKVKey :one
SELECT key, guild_id, value, expires_at, created_at, updated_at FROM kv_store WHERE key = $1 AND guild_id = $2
`

type GetKVKeyParams struct {
	Key     string
	GuildID string
}

func (q *Queries) GetKVKey(ctx context.Context, arg GetKVKeyParams) (KvStore, error) {
	row := q.db.QueryRowContext(ctx, getKVKey, arg.Key, arg.GuildID)
	var i KvStore
	err := row.Scan(
		&i.Key,
		&i.GuildID,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const increaseKVKey = `-- name: IncreaseKVKey :one
INSERT INTO kv_store (
    key, 
    guild_id, 
    value, 
    expires_at, 
    created_at, 
    updated_at
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5, 
    $6
) ON CONFLICT (key, guild_id)
DO UPDATE SET 
    value = kv_store.value::int + EXCLUDED.value::int, 
    expires_at = EXCLUDED.expires_at, 
    updated_at = EXCLUDED.updated_at
RETURNING key, guild_id, value, expires_at, created_at, updated_at
`

type IncreaseKVKeyParams struct {
	Key       string
	GuildID   string
	Value     string
	ExpiresAt sql.NullTime
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) IncreaseKVKey(ctx context.Context, arg IncreaseKVKeyParams) (KvStore, error) {
	row := q.db.QueryRowContext(ctx, increaseKVKey,
		arg.Key,
		arg.GuildID,
		arg.Value,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i KvStore
	err := row.Scan(
		&i.Key,
		&i.GuildID,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchKVKeys = `-- name: SearchKVKeys :many
SELECT key, guild_id, value, expires_at, created_at, updated_at FROM kv_store WHERE key LIKE $1 AND guild_id = $2
`

type SearchKVKeysParams struct {
	Key     string
	GuildID string
}

func (q *Queries) SearchKVKeys(ctx context.Context, arg SearchKVKeysParams) ([]KvStore, error) {
	rows, err := q.db.QueryContext(ctx, searchKVKeys, arg.Key, arg.GuildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []KvStore
	for rows.Next() {
		var i KvStore
		if err := rows.Scan(
			&i.Key,
			&i.GuildID,
			&i.Value,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setKVKey = `-- name: SetKVKey :exec
INSERT INTO kv_store (
    key, 
    guild_id, 
    value, 
    expires_at, 
    created_at, 
    updated_at
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5, 
    $6
) ON CONFLICT (key, guild_id) 
DO UPDATE SET 
    value = EXCLUDED.value, 
    expires_at = EXCLUDED.expires_at, 
    updated_at = EXCLUDED.updated_at
`

type SetKVKeyParams struct {
	Key       string
	GuildID   string
	Value     string
	ExpiresAt sql.NullTime
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) SetKVKey(ctx context.Context, arg SetKVKeyParams) error {
	_, err := q.db.ExecContext(ctx, setKVKey,
		arg.Key,
		arg.GuildID,
		arg.Value,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
